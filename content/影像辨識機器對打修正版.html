<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>計算機程式教材</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>40623128 - 個人課程網站</h1> <confmenu>
<ul>
<li><a href="index.html">主頁</a></li>
<li><a href="sitemap.html"> 網站檢索</a></li>
<li><a href="./../reveal/index.html">投影片</a></li>
<li><a href="./../reveal/index4.html">期中簡報</a></li>
<li><a href="./../reveal/index5.html">產品協同期末簡報</a></li>
<li><a href="./../blog/index.html">部落格</a></li>
<li><a href="https://www.onshape.com/"> Onshape</a></li>
<li><a href="https://www.merriam-webster.com/"> Dictionary</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><li><a href='協同產品設計實習期末報告影片.html'>協同產品設計實習期末報告影片</a><li><a href='手足球.html'>手足球</a><ul><li><a href='期中前.html'>期中前</a><ul><li><a href='自動回擊.html'>自動回擊</a><li><a href='手足球手控與電腦對打.html'>手足球手控與電腦對打</a><li><a href='手足球電腦對電腦.html'>手足球電腦對電腦</a><li><a href='手足球雙人對打.html'>手足球雙人對打</a></li></ul><li><a href='期末前.html'>期末前</a><ul><li><a href='影像辨識尋找球和桿子位置.html'>影像辨識尋找球和桿子位置</a><li><a href='影像辨識機器對打.html'>影像辨識機器對打</a><li><a href='影像辨識機器對打修正版.html'>影像辨識機器對打修正版</a><li><a href='更改影像辨識方式.html'>更改影像辨識方式</a><li><a href='影像辨識多個球員踢球.html'>影像辨識多個球員踢球</a></li></ul><li><a href='遭遇問題與解決方式.html'>遭遇問題與解決方式</a></li></ul><li><a href='OnShape操作內容.html'>OnShape操作內容</a><ul><li><a href='W1.html'>W1</a><ul><li><a href='W1操作影片.html'>W1操作影片</a><li><a href='單位設定.html'>單位設定</a><li><a href='W1單字.html'>W1單字</a></li></ul><li><a href='W2.html'>W2</a><ul><li><a href='W2操作影片.html'>W2操作影片</a></li></ul><li><a href='W3.html'>W3</a><ul><li><a href='W3操作影片.html'>W3操作影片</a></li></ul><li><a href='W4.html'>W4</a><ul><li><a href='W4操作影片.html'>W4操作影片</a><li><a href='W4單字.html'>W4單字</a></li></li></ul></ul><li><a href='git功能.html'>git功能</a><li><a href='CSS編輯.html'>CSS編輯</a><ul><li><a href='css參考資料.html'>css參考資料</a></li></ul><li><a href='FeatureScript介紹.html'>FeatureScript介紹</a><ul><li><a href='如何使用自訂義的功能.html'>如何使用自訂義的功能</a><li><a href='如何開啟新的Feature studio.html'>如何開啟新的Feature studio</a><li><a href='建立輸入表單介紹.html'>建立輸入表單介紹</a><li><a href='自製繪圖功能練習-星星.html'>自製繪圖功能練習-星星</a><li><a href='參考資料.html'>參考資料</a></li></ul><li><a href='FeatureScript.html'>FeatureScript</a><ul><li><a href='六角填充.html'>六角填充</a><li><a href='六角填充第二版.html'>六角填充第二版</a><ul><li><a href='表單.html'>表單</a><li><a href='繪圖功能長度版本.html'>繪圖功能長度版本</a><li><a href='繪圖功能外力版本.html'>繪圖功能外力版本</a></li></ul><li><a href='FeatureScript參考資料.html'>FeatureScript參考資料</a></li></ul></nav><section>影像辨識機器對打 << <a href='影像辨識機器對打.html'>Previous</a> <a href='更改影像辨識方式.html'>Next</a> >> 更改影像辨識方式<br /><h1>影像辨識機器對打修正版</h1>
<p>解決了上週若球至桿子後方將無法回擊的問題</p>
<p>影片:</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/vXuvJptDWkA" width="560"></iframe></p>
<p>vrep設定檔:<a href="https://github.com/mdecadp2018/tree/gh-pages/TableFootBall/v-rep/tablefootball%20-%200507.ttt">tablefootball - 0507.ttt</a></p>
<p>程式檔:<a href="https://github.com/mdecadp2018/tree/gh-pages/TableFootBall/v-rep/Image_Detection_play_v2.py">Image_Detection_play_v2.py</a></p>
<p>程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import vrep
import time

from PIL import Image as I
import array

import cv2, numpy

# function based on: 
#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py
def speed(handle,speed):
    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)
        
def track_green_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_green = numpy.array([60-range,100,100])
    upper_green = numpy.array([60+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_green, upper_green)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

def track_blue_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_red = numpy.array([0-range,100,100])
    upper_red = numpy.array([0+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_red, upper_red)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr
    
def track_red_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_blue = numpy.array([120-range,100,100])
    upper_blue = numpy.array([120+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

vrep.simxFinish(-1)
clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!=-1:
  print('Connected to remote API server')
  # get vision sensor objects
  res, v0 = vrep.simxGetObjectHandle(clientID, 'vs1', vrep.simx_opmode_oneshot_wait)
  res, v1 = vrep.simxGetObjectHandle(clientID, 'vs2', vrep.simx_opmode_oneshot_wait)
  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)
  err,Sphere_handle=vrep.simxGetObjectHandle(clientID,'Sphere',vrep.simx_opmode_oneshot_wait)
  err,BRod_handle=vrep.simxGetObjectHandle(clientID,'BRod',vrep.simx_opmode_oneshot_wait)
  err,BRev_handle=vrep.simxGetObjectHandle(clientID,'BRev',vrep.simx_opmode_oneshot_wait)
  err,BMo_handle=vrep.simxGetObjectHandle(clientID,'BMo',vrep.simx_opmode_oneshot_wait)
  err,RRev_handle=vrep.simxGetObjectHandle(clientID,'RRev',vrep.simx_opmode_oneshot_wait)
  err,RMo_handle=vrep.simxGetObjectHandle(clientID,'RMo',vrep.simx_opmode_oneshot_wait)
  err,RRod_handle=vrep.simxGetObjectHandle(clientID,'RRod',vrep.simx_opmode_oneshot_wait)
  time.sleep(1)
  while (vrep.simxGetConnectionId(clientID) != -1):
    # get image from vision sensor 'v0'
    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)
    if err == vrep.simx_return_ok:
        image_byte_array = array.array('b', image)
        #print(image_byte_array)
        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)
        img2 = numpy.asarray(image_buffer)
      # try to find something green
        ret_green = track_green_object(img2)
        ret_red = track_red_object(img2)
        ret_blue = track_blue_object(img2)
        #print('B=',ret_blue[1],ret_blue[0])#y軸座標為0 x軸座標為1
        #print('R=',ret_red[1],ret_red[0])
        #print('G=',ret_green[1],ret_green[0])
        #'''
        if ret_green != None and ret_red != None and ret_blue != None:
            Bv = float(ret_green[0])-float(ret_blue[0])
            BBv=float(ret_green[1])-float(ret_blue[1])
            Rv = float(ret_green[0])-float(ret_red[0])
            RRv=float(ret_green[1])-float(ret_red[1])
            if Bv&lt;0.0:
                speed(BMo_handle,Bv*-0.02)
            elif Bv&gt;0.0:
                speed(BMo_handle,Bv*-0.02)
            else:
                pass
                
                
            if Rv&lt;0.0:
                speed(RMo_handle,Rv*-0.02)
            elif Rv&gt;0.0:
                speed(RMo_handle,Rv*-0.02)
            else:
                pass
                
                
            if  ret_blue[1] &gt;=18 and ret_green[1] &lt;= 17:
                if ret_green[0] &gt;62.5:
                    speed(BMo_handle,2)
                    time.sleep(0.1)
                    speed(BRev_handle,20)
                    time.sleep(0.1)
                    if ret_green[1] != ret_blue[1]:
                        Bv = float(ret_green[0])-float(ret_blue[0])
                        if Bv&lt;0.0:
                            speed(BMo_handle,Bv*-0.02)
                        elif Bv&gt;0.0:
                            speed(BMo_handle,Bv*-0.02)
                        else:
                            pass
                    else:
                        speed(BRev_handle,2)
                    
                elif ret_green[0] &lt;62.5:
                    speed(BMo_handle,-2)
                    time.sleep(0.1)
                    speed(BRev_handle,20)
                    time.sleep(0.1)
                    if ret_green[1] != ret_blue[1]:
                        Bv = float(ret_green[0])-float(ret_blue[0])
                        if Bv&lt;0.0:
                            speed(BMo_handle,Bv*-0.02)
                        elif Bv&gt;0.0:
                            speed(BMo_handle,Bv*-0.02)
                        else:
                            pass
                    else:
                        speed(BRev_handle,2)
            elif ret_green[0]-ret_blue[0] &gt;= -3 and ret_green[0]-ret_blue[0] &lt;= 3:
                if BBv&lt;10.0:
                    speed(BRev_handle,-2)
                elif BBv&gt;10.0:
                    speed(BRev_handle,2)
                else:
                    pass
                    
            
            if  ret_red[1] &lt;=236 and ret_green[1] &gt;= 237:
                if ret_green[0] &gt;62.5:
                    speed(RMo_handle,2)
                    time.sleep(0.1)
                    speed(RRev_handle,-20)
                    time.sleep(0.1)
                    if ret_green[1] != ret_red[1]:
                        Rv = float(ret_green[0])-float(ret_red[0])
                        if Rv&lt;0.0:
                            speed(RMo_handle,Rv*-0.02)
                        elif Rv&gt;0.0:
                            speed(RMo_handle,Rv*-0.02)
                        else:
                            pass
                    else:
                        speed(RRev_handle,2)
                    
                elif ret_green[0] &lt;62.5:
                    speed(RMo_handle,-2)
                    time.sleep(0.1)
                    speed(RRev_handle,-20)
                    time.sleep(0.1)
                    if ret_green[1] != ret_red[1]:
                        Rv = float(ret_green[0])-float(ret_red[0])
                        if Rv&lt;0.0:
                            speed(RMo_handle,Rv*-0.02)
                        elif Rv&gt;0.0:
                            speed(RMo_handle,Rv*-0.02)
                        else:
                            pass
                    else:
                        speed(RRev_handle,2)
            elif ret_green[0]-ret_red[0] &gt;= -3 and ret_green[0]-ret_red[0] &lt;= 3:
                if RRv&lt;-10.0:
                    speed(RRev_handle,-2)
                elif RRv&gt;-10.0:
                    speed(RRev_handle,2)
                else:
                    pass
                    
            #'''
      # overlay rectangle marker if something is found by OpenCV
        if ret_green:
            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)
          # return image to sensor 'v1'
        if ret_red:
            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)
        if ret_blue:
            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)
        img2 = img2.ravel()
        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)
    elif err == vrep.simx_return_novalue_flag:
      print("no image yet")
      pass
    else:
      print(err)
else:
  print("Failed to connect to remote API Server")
  vrep.simxFinish(clientID)</pre>
<br />影像辨識機器對打 << <a href='影像辨識機器對打.html'>Previous</a> <a href='更改影像辨識方式.html'>Next</a> >> 更改影像辨識方式</section></div></body></html>