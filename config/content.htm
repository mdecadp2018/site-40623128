<h1>簡介</h1>
<p>2018年四設計二甲40623128 張華倞 電腦輔助設計實習的倉儲.</p>
<p>倉儲:<a href="https://github.com/mdecadp2018/site-40623128">https://github.com/mdecadp2018/site-40623128</a></p>
<p>期末分組網站:<a href="https://mdecadp2018.github.io/finalproject-ag4">https://mdecadp2018.github.io/finalproject-ag4</a></p>
<p>期末分組倉儲:<a href="https://github.com/mdecadp2018/finalproject-ag4">https://github.com/mdecadp2018/finalproject-ag4</a></p>
<p></p><h1>OnShape操作內容</h1>
<h2>W1</h2>
<h3>W1操作影片</h3>
<p><a href="https://www.youtube.com/watch?v=uoONqs_QQdY">影片位置</a></p>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="510" src="//www.youtube.com/embed/uoONqs_QQdY" width="960"></iframe></p>
<h3>單位設定</h3>
<p>步驟如下圖</p>
<p><img alt="" height="513" src="/images/設定單位.png" width="604"/></p>
<p></p>
<p><img alt="" height="685" src="/images/工作區單位.png" width="1128"/></p>
<p><img alt="" height="340" src="/images/工作區單位設定.png" width="190"/></p>
<h3>W1單字</h3>
<p><a href="https://www.merriam-webster.com/dictionary/account">account</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/navigating">navigating</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/foundational">foundational</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/gestures">gestures</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/intro">intro</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/visualization">visualization</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/curriculum">curriculum</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/course">course</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/instructor">instructor</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/introduces">introduce</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/manufacture">manufacture</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/divided">divided</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/assessment">assessment</a></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h2>W2</h2>
<h3>W2操作影片</h3>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="510" src="https://www.youtube.com/embed/Qbu8EIs1Gos" width="960"></iframe>w</p>
<h2>W3</h2>
<h3>W3操作影片</h3>
<p><iframe allowfullscreen="allowfullscreen" height="510" src="//www.youtube.com/embed/vanqfJZ5kp0" width="910"></iframe>z</p>
<h2>W4</h2>
<h3>W4操作影片</h3>
<p>學習各零件之間利用自由度限制進行組裝</p>
<p><iframe allowfullscreen="allowfullscreen" height="510" src="//www.youtube.com/embed/TZGAPkIk2e4" width="910"></iframe></p>
<h3>W4單字</h3>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/assemblies" style="background-color: #ffffff;">assemblies</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/manipulating">manipulating</a><a href="https://www.merriam-webster.com/dictionary/discuss"></a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/discuss">discuss</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/dynamic">dynamic</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/critical">critical</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/utilizes">utilizes</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/constraints">constraints</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/entities">entities</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/unconstrained">unconstrained</a></span></p>
<p><span style="background-color: #ffffff;"><a href="https://www.merriam-webster.com/dictionary/typically">Typically</a></span></p>
<p><a href="https://www.merriam-webster.com/dictionary/orientation">orientation</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/preventing">preventing</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/norm">norm</a></p>
<p><a href="https://www.merriam-webster.com/dictionary/cantilever">Cantilever</a></p>
<p></p>
<p><span style="background-color: #ffffff;"></span></p>
<p><span style="background-color: #ffffff;"></span></p>
<p><span style="background-color: #ffffff;"></span></p>
<h1>git功能</h1>
<p>git status (展示目前狀態)</p>
<p>git branch 分支名 (創建新分支)</p>
<p><span>git log --oneline --graph --all (檢查各提交間的關聯)</span></p>
<p>git checkout 分支名 (轉換分支)</p>
<p><span> git merge 分支名 (合併分支)</span></p>
<p><span>git log (查看版次)</span></p>
<h1>CSS編輯</h1>
<h2>參考資料</h2>
<p>語法參考:<a href="https://www.1keydata.com/css-tutorial/tw/">https://www.1keydata.com/css-tutorial/tw/</a></p>
<p>協助工具一:<a href="https://www.css3maker.com/">https://www.css3maker.com/</a></p>
<p>協助工具二:google瀏覽器F12功能</p>
<p>背景圖來源:<a href="https://www.pexels.com/photo/silhouette-of-mountains-1323550/">https://www.pexels.com/photo/silhouette-of-mountains-1323550/</a></p>
<p>顏色選擇:<a href="https://color.adobe.com/zh/create/color-wheel/">https://color.adobe.com/zh/create/color-wheel/</a></p>
<h1>FeatureScript介紹</h1>
<h2>如何使用自訂義的功能</h2>
<p>在零件圖功能區的最右端處點選即可使用。</p>
<p><img alt="" height="673" src="/images/開啟位置.png" width="880"/></p><h2>如何開啟新的Feature studio</h2>
<p>首先至新的圖檔，左下角加號處</p>
<p>如下圖</p>
<p><img alt="" height="600" src="/images/程式開啟.png" width="839"/></p><h2>建立輸入表單介紹</h2>
<p>快捷指令列</p>
<p><img alt="" height="600" src="/images/快捷.png" width="839"/></p>
<p>首先使用第一個New Feature建立新的特徵</p>
<p><img alt="" height="600" src="/images/新增特徵.png" width="839"/></p>
<p>功能主要是建立一個特徵功能的架構如下圖</p>
<p><img alt="" height="677" src="/images/特徵格式.png" width="947"/></p>
<p>可以藉由輸入程式於下圖紅框處，製作表單與繪畫功能</p>
<p><img alt="" height="677" src="/images/特徵編輯.png" width="947"/></p>
<p>建立表單的各項輸入項目，可以於下圖位置點選所需項目。</p>
<p><img alt="" height="572" src="/images/表單功能1.png" width="800"/></p>
<p>舉例如下圖使用第一個長度參數</p>
<p><img alt="" height="433" src="/images/Length.png" width="791"/></p>
<p>程式新增於表單輸入項目，如以下</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">FeatureScript 975;
import(path : "onshape/std/geometry.fs", version : "975.0");


annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "My Length" }
        isLength(definition.myLength, LENGTH_BOUNDS);
        
    }
    {
        
    });</pre>
<p>使用該功能就會出現長度輸入欄。</p>
<p><img alt="" height="79" src="/images/長度表單.png" width="223"/></p>
<p>程式最後寫的LENGHT_BOUNDS是限制輸入值</p>
<p>詳細內容可至以下連結運用Ctrl+F尋找<a href="https://cad.onshape.com/FsDoc/library.html#module-valueBounds.fs">valueBounds</a>查詢</p>
<p><a href="https://cad.onshape.com/FsDoc/library.html#category-Modeling">https://cad.onshape.com/FsDoc/library.html#category-Modeling</a></p>
<h2>繪圖功能範例-星星</h2><h1>FeatureScript</h1>
<h2>六角填充</h2>
<p>六角填充註解</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

// 設定填充百分比範圍為1~100，預設10
export const INFILL_BOUNDS =   ///設定值域
{
            "min"        : 1,
            "max"        : 100,
            (unitless)   : [1, 10, 100]
        } as IntegerBoundSpec;  //限定整數

// parameter values (real numbers) in various document unit systems with defaults
export const HEX_BOUNDS =
{
            "min"        : 1 * millimeter,
            "max"        : 100 * millimeter,
            (meter)      : [0.0, 0.025, 500],
            (centimeter) : 0.5,
            (millimeter) : [1, 5, 100],
            (inch)       : .25,
            (foot)       : 0.015,
            (yard)       : 0.005
        } as LengthBoundSpec; //限定整數
        
//-----------------        

annotation { "Feature Type Name" : "HexInfill" }
export const HexInfill = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Part To Hex Infill", "Filter" : EntityType.BODY, "MaxNumberOfPicks" : 1 }  //表單名稱:Part To Hex Infill,可選項目:實體,最大選擇數:1
        definition.PartToInfill is Query;               //把所選項目定義為PartToInfill之後要用到只要輸入definition.PartToInfill就代表所選的實體

        annotation { "Name" : "Wall Thickness" }        //表單名稱:Wall Thickness
        isLength(definition.WallThickness, HEX_BOUNDS); //輸入長度且基礎設定由HEX_BOUNDS輸入

        annotation { "Name" : "Hex Width" }             //表單名稱:Hex Width
        isLength(definition.HexWidth, HEX_BOUNDS);

        annotation { "Name" : "% InFill" }             //表單名稱:% InFill
        isInteger(definition.InFill, INFILL_BOUNDS);

        annotation { "Name" : "HexPreview", "Default" : true }//表單名稱:HexPreview 預設:是
        definition.HexPreview is boolean;                     //設定輸出為布林值(輸出1或0判斷是或否)
    }

//-----------------

    {
        // get the limits of the bounding box
        var boundingBox is Box3d = evBox3d(context, { "topology" : definition.PartToInfill }); //運用所選實體找出邊界框
        var bbx1 = boundingBox.minCorner[0];            //定義所選實體中最小x座標為bbx1
        var bby1 = boundingBox.minCorner[1];            //定義所選實體中最小y座標為bby1
        var bbz1 = boundingBox.minCorner[2];            //定義所選實體中最小z座標為bbz1
        var bbx2 = boundingBox.maxCorner[0];            //定義所選實體中最大x座標為bbx2
        var bby2 = boundingBox.maxCorner[1];            //定義所選實體中最大y座標為bby2

        // from the hex width, define some other variables
        var FullWidthDimless = (definition.HexWidth) / meter;    //六角形內接圓直徑
        var HalfWidthDimless = (definition.HexWidth / 2) / meter;//六角形內接圓半徑
        var LongArm = HalfWidthDimless / cos(30 * degree);       //六角形外接圓半徑
        var Flat = (HalfWidthDimless * tan(30 * degree)) * 2;    //六角形邊長
        var Yincrement = LongArm + (Flat / 2);                   //兩六角形連心線至上方六角型垂直距離

        var TotalXcells = ceil((bbx2 - bbx1) / definition.HexWidth) + 1;   //定義x方向六邊形總數 (ceil 大於某數的最大整數)
        var TotalYcells = ceil((bby2 - bby1) / (Yincrement * meter)) + 1;  //定義y方向六邊形總數

        var AreaOfHex = (6 * (HalfWidthDimless * HalfWidthDimless)) / (sqrt(3)); //六邊形面積     (6*三角形面積)
        var ReducedArea = AreaOfHex * ((100 - definition.InFill) / 100);         //六邊形縮小後面積 (由表單瑱入% InFill之值決定縮小多少)
        var ReducedHalfWidth = sqrt((sqrt(3) * ReducedArea) / 6);                //反推縮小面積後的外接圓半徑
        var ThickenAmount = (FullWidthDimless - (ReducedHalfWidth * 2)) / 2;     //邊長縮小長度

        LongArm -= ThickenAmount; // this is the 'radius' of the reduced (infilled) hex 把縮小長度轉為負數

        // define some variables that we will use to create the hex sketch 定義製作六邊形草圖的數值
        var Origin = vector([0, 0, bbz1]) * meter; // origin (lower z bounding box) 原點位置
        var Normal = vector([0, 0, 1]);            // sketch normal (z+)    草圖法線方向
        var Xdir   = vector([1, 0, 0]);            // define x direction in the new sketch 新草圖中的x方向

        // create the plane on which to generate the sketch  創建用來生成草圖的平面
        var HexPlane is Plane = plane(Origin, Normal, Xdir);

        // create sketch  創建草圖
        var HexSketch = newSketchOnPlane(context, id + "HexSketch", {
                "sketchPlane" : HexPlane    //草圖平面為HexPlane
            });

        // all the hexes are the same size so we only have to calculate the 6 node locations (relative to the hex center) one time
        var x1 = makeArray(6);  //定義數列 x1 (6個值)
        var y1 = makeArray(6);  //定義數列 y1 (6個值)
        var x2 = makeArray(6);  //定義數列 x2 (6個值)
        var y2 = makeArray(6);  //定義數列 y2 (6個值)

        for (var i = 0; i &lt; 6; i += 1)  //for迴圈 
        {
            var ang = i * 60;                           //定義ang 第1次計算為60 第2次計算為120 ....
            x1[i] = LongArm * cos((ang - 30) * degree); //直線繪製六邊形起始點x座標
            y1[i] = LongArm * sin((ang - 30) * degree); //直線繪製六邊形起始點y座標
            x2[i] = LongArm * cos((ang + 30) * degree); //直線繪製六邊形結束點x座標
            y2[i] = LongArm * sin((ang + 30) * degree); //直線繪製六邊形結束點y座標
        }

        // Begin loop to draw hex line entities 開始繪製六邊形

        for ( var y = 0; y &lt; TotalYcells; y += 1)    //重複執行(Y軸六邊形總數)次
        {
            var Xcenter = (bbx1 - definition.HexWidth) / meter;        //最小x座標-內接圓直徑
            var Ycenter = (bby1 + (y * (Yincrement * meter))) / meter;//最小y座標+(兩六角形連心線至上方六角型垂直距離)

            if (y % 2 != 0) // odd row           y/2餘數不為0時
                Xcenter += (FullWidthDimless / 2); //Xcenter的值 增加六角形內接圓半徑

            for (var x = 0; x &lt; TotalXcells; x += 1) //重複執行(X軸六邊形總數)次
            {
                Xcenter += FullWidthDimless;          //Xcenter的值 增加六角形內接圓直徑

                for (var i = 0; i &lt; 6; i += 1)
                {
                    var LineStart = vector([Xcenter + x1[i], Ycenter + y1[i]]) * meter; //各線段起點座標
                    var LineEnd   = vector([Xcenter + x2[i], Ycenter + y2[i]]) * meter; //各線段終點座標

                    // generate a unique id for every line entity in the sketch
                    var LineID = "line"~"-"~x~"-"~y~"-"~i;

                    // draw a line 
                    skLineSegment(HexSketch, LineID, {
                                "start" : LineStart,
                                "end"   : LineEnd
                            });
                }
            }
        }

        // End line drawing loop 草圖繪畫結束

        skSolve(HexSketch); // solve the sketch. Must solve the sketch before you can do anything else. 結束草圖

        // do this only if the 'preview' option is un-checked 只在取消預覽時執行以下
        if (!definition.HexPreview)
        {
            // make a copy of the original part 複製所選實體
            transform(context, id + "CopyOfOriginal", {
                        "entities"      : definition.PartToInfill,
                        "transformType" : TransformType.COPY,
                        "makeCopy"      : true });

            // cut extrude the entire sketch through the copy of the original part 切除擠出部分
            extrude(context, id + "HexCuts", {
                        "entities"      : qSketchRegion(id + "HexSketch"),
                        "endBound"      : BoundingType.THROUGH_ALL,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope"  : false,
                        "booleanScope"  : qCreatedBy(id + "CopyOfOriginal", EntityType.BODY)
                    });

            // this debug statement shows a graphical preview of the result of the hex-removed-copy
            debug(context, qCreatedBy(id + "CopyOfOriginal", EntityType.BODY));

            // shell (hollow) the original part - if this is not possible (fails) then show error message and exit 如果無法執行則跳出錯誤訊息並結束
            try
            {
                shell(context, id + "shell", {
                            "parts"     : definition.PartToInfill,
                            "thickness" : definition.WallThickness,
                            "isHollow"  : true
                        });
            }
            
            catch
            {
                throw regenError("Unable to shell this part with the current wall thickness");
            }

            // querry that returns the hex-removed-copy and the shelled (hollow) original part
            // note: it is the first item in the querry that retains its identity (name, color etc)
            var PartAndHex = qUnion([definition.PartToInfill, qCreatedBy(id + "CopyOfOriginal", EntityType.BODY)]);

            //boolean union of shelled (hollow) part and hex-removed-copy
            opBoolean(context, id + "BooleanUnion", {
                        "tools"         : PartAndHex,
                        "operationType" : BooleanOperationType.UNION
                    });

            //querry that returns all the entities in the hex sketch
            var StuffInSketch = qCreatedBy(id + "HexSketch", EntityType.BODY);
            
            // delete all the sketch entities
            opDeleteBodies(context, id + "DeleteSketchContents", { "entities" : StuffInSketch });

        }
        // endif HexPreview

    });
    
//-----------------
</pre>
<h2>六角填充第二版</h2>
<h3>表單</h3>
<p>由原本的</p>
<p><img alt="" height="209" src="/images/20181224.png" width="219"/></p>
<p>更改為下拉式可選所需類型</p>
<p><img alt="" height="218" src="/images/2018-12-24_21-12-16.gif" width="222"/></p>
<p>原始碼:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">FeatureScript 975;
import(path : "onshape/std/geometry.fs", version : "975.0");
  
        

annotation { "Feature Type Name" : "Hex In fill" }

export const HexInfill2 = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Part To Hex Infill", "Filter" : EntityType.BODY, "MaxNumberOfPicks" : 1 }  //表單名稱:Part To Hex Infill,可選項目:實體,最大選擇數:1
        definition.PartToInfill is Query;               //把所選項目定義為PartToInfill之後要用到只要輸入definition.PartToInfill就代表所選的實體
        
        annotation { "Name" : "Input type" }
        definition.HexInputType is HexInputType;
        
        //長度表單開始處
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "Wall Thickness" }        //表單名稱:Wall Thickness
            isLength(definition.WallThickness, HEX_BOUNDS);
        }
        
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "Hex Width" }             //表單名稱:Hex Width
            isLength(definition.HexWidth, HEX_BOUNDS);
        }
        
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "% InFill" }              //表單名稱:% InFill
            isInteger(definition.InFill, INFILL_BOUNDS);
        }
        //長度表單結束
        
        //外力表單開始處
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Force (N)" }             //表單名稱:Force (N)
            isReal(definition.Force, POSITIVE_REAL_BOUNDS); 
        }
        
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Compressive Strength (Mpa)" }        //表單名稱:Compressive Strength (Mpa)
            isInteger(definition.Compressive, POSITIVE_COUNT_BOUNDS);   //所填數值必需&gt;0
        }
        
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Safety Factor" }        //表單名稱:Compressive Strength (Mpa)
            isInteger(definition.SafetyFactor, POSITIVE_COUNT_BOUNDS);  //所填數值必需&gt;0
        }
        //外力表單結束
        
        annotation { "Name" : "HexPreview", "Default" : true }//表單名稱:HexPreview 預設:是
        definition.HexPreview is boolean;                     //設定輸出為布林值(輸出1或0判斷是或否)
    }
    
    
    
    {
        

    });
    
export enum HexInputType
{
    annotation { "Name" : "Length" }
    length,
    annotation { "Name" : "Force" }
    force
}


export const INFILL_BOUNDS =   ///設定值域
{
            (unitless)   : [1, 10, 100]
        } as IntegerBoundSpec;  //限定整數
    
export const HEX_BOUNDS =
{
            (millimeter) : [1, 5, 100],
        } as LengthBoundSpec; //限定整數</pre>
<p></p>
<h3>繪圖功能長度版本</h3>
<p>繪製長度版本內六角形</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">FeatureScript 975;
import(path : "onshape/std/geometry.fs", version : "975.0");
  
        

annotation { "Feature Type Name" : "Hex In fill" }

export const HexInfill2 = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Part To Hex Infill", "Filter" : EntityType.BODY, "MaxNumberOfPicks" : 1 }  //表單名稱:Part To Hex Infill,可選項目:實體,最大選擇數:1
        definition.PartToInfill is Query;               //把所選項目定義為PartToInfill之後要用到只要輸入definition.PartToInfill就代表所選的實體
        
        annotation { "Name" : "Input type" }
        definition.HexInputType is HexInputType;
        
        //長度表單開始處
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "Wall Thickness" }        //表單名稱:Wall Thickness
            isLength(definition.WallThickness, HEX_BOUNDS);
        }
        
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "Hex Width" }             //表單名稱:Hex Width
            isLength(definition.HexWidth, HEX_BOUNDS);
        }
        
        if (definition.HexInputType == HexInputType.length)
        {
            annotation { "Name" : "% InFill" }              //表單名稱:% InFill
            isInteger(definition.InFill, INFILL_BOUNDS);
        }
        //長度表單結束
        
        //外力表單開始處
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Force (N)" }             //表單名稱:Force (N)
            isReal(definition.Force, POSITIVE_REAL_BOUNDS); 
        }
        
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Compressive Strength (Mpa)" }        //表單名稱:Compressive Strength (Mpa)
            isInteger(definition.Compressive, POSITIVE_COUNT_BOUNDS);   //所填數值必需&gt;0
        }
        
        if (definition.HexInputType == HexInputType.force)
        {
            annotation { "Name" : "Safety Factor" }        //表單名稱:Compressive Strength (Mpa)
            isInteger(definition.SafetyFactor, POSITIVE_COUNT_BOUNDS);  //所填數值必需&gt;0
        }
        //外力表單結束
        
        annotation { "Name" : "HexPreview", "Default" : true }//表單名稱:HexPreview 預設:是
        definition.HexPreview is boolean;                     //設定輸出為布林值(輸出1或0判斷是或否)
    }
    
    
    
    {
        // get the limits of the bounding box
        var boundingBox is Box3d = evBox3d(context, { "topology" : definition.PartToInfill }); //運用所選實體找出邊界框
        var bbx1 = boundingBox.minCorner[0];            //定義所選實體中最小x座標為bbx1
        var bby1 = boundingBox.minCorner[1];            //定義所選實體中最小y座標為bby1
        var bbz1 = boundingBox.minCorner[2];            //定義所選實體中最小z座標為bbz1
        var bbx2 = boundingBox.maxCorner[0];            //定義所選實體中最大x座標為bbx2
        var bby2 = boundingBox.maxCorner[1];            //定義所選實體中最大y座標為bby2

        // from the hex width, define some other variables
        var FullWidthDimless = (definition.HexWidth) / meter;    //六角形內接圓直徑
        var HalfWidthDimless = (definition.HexWidth / 2) / meter;//六角形內接圓半徑
        var LongArm = HalfWidthDimless / cos(30 * degree);       //六角形外接圓半徑
        var Flat = (HalfWidthDimless * tan(30 * degree)) * 2;    //六角形邊長
        var Yincrement = LongArm + (Flat / 2);                   //兩六角形連心線至上方六角型垂直距離

        var TotalXcells = ceil((bbx2 - bbx1) / definition.HexWidth) + 1;   //定義x方向六邊形總數 (ceil 大於某數的最大整數)
        var TotalYcells = ceil((bby2 - bby1) / (Yincrement * meter)) + 1;  //定義y方向六邊形總數

        var AreaOfHex = (6 * (HalfWidthDimless * HalfWidthDimless)) / (sqrt(3)); //六邊形面積     (6*三角形面積)
        var ReducedArea = AreaOfHex * ((100 - definition.InFill) / 100);         //六邊形縮小後面積 (由表單瑱入% InFill之值決定縮小多少)
        var ReducedHalfWidth = sqrt((sqrt(3) * ReducedArea) / 6);                //反推縮小面積後的外接圓半徑
        var ThickenAmount = (FullWidthDimless - (ReducedHalfWidth * 2)) / 2;     //邊長縮小長度

        LongArm -= ThickenAmount; // this is the 'radius' of the reduced (infilled) hex 把縮小長度轉為負數

        // define some variables that we will use to create the hex sketch 定義製作六邊形草圖的數值
        var Origin = vector([0, 0, bbz1]) * meter; // origin (lower z bounding box) 原點位置
        var Normal = vector([0, 0, 1]);            // sketch normal (z+)    草圖法線方向
        var Xdir   = vector([1, 0, 0]);            // define x direction in the new sketch 新草圖中的x方向

        // create the plane on which to generate the sketch  創建用來生成草圖的平面
        var HexPlane is Plane = plane(Origin, Normal, Xdir);

        // create sketch  創建草圖
        var HexSketch = newSketchOnPlane(context, id + "HexSketch", {
                "sketchPlane" : HexPlane    //草圖平面為HexPlane
            });

        // all the hexes are the same size so we only have to calculate the 6 node locations (relative to the hex center) one time
        var x1 = makeArray(6);  //定義數列 x1 (6個值)
        var y1 = makeArray(6);  //定義數列 y1 (6個值)
        var x2 = makeArray(6);  //定義數列 x2 (6個值)
        var y2 = makeArray(6);  //定義數列 y2 (6個值)

        for (var i = 0; i &lt; 6; i += 1)  //for迴圈 
        {
            var ang = i * 60;                           //定義ang 第1次計算為60 第2次計算為120 ....
            x1[i] = LongArm * cos((ang - 30) * degree); //直線繪製六邊形起始點x座標
            y1[i] = LongArm * sin((ang - 30) * degree); //直線繪製六邊形起始點y座標
            x2[i] = LongArm * cos((ang + 30) * degree); //直線繪製六邊形結束點x座標
            y2[i] = LongArm * sin((ang + 30) * degree); //直線繪製六邊形結束點y座標
        }

        // Begin loop to draw hex line entities 開始繪製六邊形

        for ( var y = 0; y &lt; TotalYcells; y += 1)    //重複執行(Y軸六邊形總數)次
        {
            var Xcenter = (bbx1 - definition.HexWidth) / meter;        //最小x座標-內接圓直徑
            var Ycenter = (bby1 + (y * (Yincrement * meter))) / meter;//最小y座標+(兩六角形連心線至上方六角型垂直距離)

            if (y % 2 != 0) // odd row           y/2餘數不為0時
                Xcenter += (FullWidthDimless / 2); //Xcenter的值 增加六角形內接圓半徑

            for (var x = 0; x &lt; TotalXcells; x += 1) //重複執行(X軸六邊形總數)次
            {
                Xcenter += FullWidthDimless;          //Xcenter的值 增加六角形內接圓直徑

                for (var i = 0; i &lt; 6; i += 1)
                {
                    var LineStart = vector([Xcenter + x1[i], Ycenter + y1[i]]) * meter; //各線段起點座標
                    var LineEnd   = vector([Xcenter + x2[i], Ycenter + y2[i]]) * meter; //各線段終點座標

                    // generate a unique id for every line entity in the sketch
                    var LineID = "line"~"-"~x~"-"~y~"-"~i;

                    // draw a line 
                    skLineSegment(HexSketch, LineID, {
                                "start" : LineStart,
                                "end"   : LineEnd
                            });
                }
            }
        }

        // End line drawing loop 草圖繪畫結束

        skSolve(HexSketch); // solve the sketch. Must solve the sketch before you can do anything else. 結束草圖

        // do this only if the 'preview' option is un-checked 只在取消預覽時執行以下
        if (!definition.HexPreview)
        {
            // make a copy of the original part 複製所選實體
            transform(context, id + "CopyOfOriginal", {
                        "entities"      : definition.PartToInfill,
                        "transformType" : TransformType.COPY,
                        "makeCopy"      : true });

            // cut extrude the entire sketch through the copy of the original part 切除擠出部分
            extrude(context, id + "HexCuts", {
                        "entities"      : qSketchRegion(id + "HexSketch"),
                        "endBound"      : BoundingType.THROUGH_ALL,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope"  : false,
                        "booleanScope"  : qCreatedBy(id + "CopyOfOriginal", EntityType.BODY)
                    });

            // this debug statement shows a graphical preview of the result of the hex-removed-copy
            debug(context, qCreatedBy(id + "CopyOfOriginal", EntityType.BODY));

            // shell (hollow) the original part - if this is not possible (fails) then show error message and exit 如果無法執行則跳出錯誤訊息並結束
            try
            {
                shell(context, id + "shell", {
                            "parts"     : definition.PartToInfill,
                            "thickness" : definition.WallThickness,
                            "isHollow"  : true
                        });
            }
            
            catch
            {
                throw regenError("Unable to shell this part with the current wall thickness");
            }

            // querry that returns the hex-removed-copy and the shelled (hollow) original part
            // note: it is the first item in the querry that retains its identity (name, color etc)
            var PartAndHex = qUnion([definition.PartToInfill, qCreatedBy(id + "CopyOfOriginal", EntityType.BODY)]);

            //boolean union of shelled (hollow) part and hex-removed-copy
            opBoolean(context, id + "BooleanUnion", {
                        "tools"         : PartAndHex,
                        "operationType" : BooleanOperationType.UNION
                    });

            //querry that returns all the entities in the hex sketch
            var StuffInSketch = qCreatedBy(id + "HexSketch", EntityType.BODY);
            
            // delete all the sketch entities
            opDeleteBodies(context, id + "DeleteSketchContents", { "entities" : StuffInSketch });

        }
        // endif HexPreview

    });
    
export enum HexInputType
{
    annotation { "Name" : "Length" }
    length,
    annotation { "Name" : "Force" }
    force
}


export const INFILL_BOUNDS =   ///設定值域
{
            (unitless)   : [1, 10, 100]
        } as IntegerBoundSpec;  //限定整數
    
export const HEX_BOUNDS =
{
            (millimeter) : [1, 5, 100],
        } as LengthBoundSpec; //限定整數</pre>
<h3>繪圖功能外力版本</h3><h2>FeatureScript參考資料</h2>
<p><span>Onshape Featurescript:</span></p>
<p><a href="https://www.onshape.com/features/custom-features" rel="nofollow">https://www.onshape.com/features/custom-features</a></p>
<p><br/><span>內建功能原始碼:</span></p>
<p><br/><a href="https://cad.onshape.com/documents/12312312345abcabcabcdeff" rel="nofollow">https://cad.onshape.com/documents/12312312345abcabcabcdeff</a></p>
<p><span>教學:</span></p>
<p><a href="https://cad.onshape.com/FsDoc/index.html" rel="nofollow">https://cad.onshape.com/FsDoc/index.html</a></p>
<p><a href="https://cadlab.mde.tw/post/tag/featurescript.html" rel="nofollow">https://cadlab.mde.tw/post/tag/featurescript.html</a></p>
<p>外力公式:</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0020768313002205#e0030">https://www.sciencedirect.com/science/article/pii/S0020768313002205#e0030</a></p>